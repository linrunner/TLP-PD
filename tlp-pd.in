#!/usr/bin/env python3
# TLP Profiles Daemon (TLP-PD)
# Implements the org.freedesktop.UPower.PowerProfile D-BUS interface with TLP as backend
#
# Copyright (c) 2025 Thomas Koch <linrunner at gmx.net> and others.
# SPDX-License-Identifier: GPL-2.0-or-later

from syslog import LOG_DAEMON
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib
import subprocess
import argparse
import logging
import logging.handlers
import os
import sys

# --- Constants
DAEMON_NAME = "TLP Profiles Daemon"
AVAILABLE_PROFILES = ["performance", "balanced", "power-saver"]

# --- D-Bus constants
BUS_NAME = "org.freedesktop.UPower.PowerProfiles"
INTERFACE_NAME = BUS_NAME
OBJECT_PATH = "/org/freedesktop/UPower/PowerProfiles"
BUS_NAME_LEGACY = "net.hadess.PowerProfiles"
INTERFACE_NAME_LEGACY = BUS_NAME_LEGACY
OBJECT_PATH_LEGACY = "/net/hadess/PowerProfiles"

# --- TLP constants
TLP_LAST_PROFILE = "@TLP_RUN@/last_pwr"
TLP_PROFILE_IDX = ["0", "1", "2"]

# --- Introspection
INTROSPECTION_XML = """
<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
  <interface name="org.freedesktop.DBus.Properties">
    <method name="Get">
      <arg type="s" name="interface_name" direction="in"/>
      <arg type="s" name="property_name" direction="in"/>
      <arg type="v" name="value" direction="out"/>
    </method>
    <method name="GetAll">
      <arg type="s" name="interface_name" direction="in"/>
      <arg type="a{sv}" name="properties" direction="out"/>
    </method>
    <method name="Set">
      <arg type="s" name="interface_name" direction="in"/>
      <arg type="s" name="property_name" direction="in"/>
      <arg type="v" name="value" direction="in"/>
    </method>
    <signal name="PropertiesChanged">
      <arg type="s" name="interface_name"/>
      <arg type="a{sv}" name="changed_properties"/>
      <arg type="as" name="invalidated_properties"/>
    </signal>
  </interface>
  <interface name="org.freedesktop.DBus.Introspectable">
    <method name="Introspect">
      <arg type="s" name="xml_data" direction="out"/>
    </method>
  </interface>
  <interface name="@PD_INTERFACE@">
    <method name="HoldProfile">
      <arg type="s" name="profile" direction="in"/>
      <arg type="s" name="reason" direction="in"/>
      <arg type="s" name="application_id" direction="in"/>
      <arg type="u" name="cookie" direction="out"/>
    </method>
    <method name="ReleaseProfile">
      <arg type="u" name="cookie" direction="in"/>
    </method>
    <method name="SyncProfile">
      <arg type="s" name="profile" direction="in"/>
    </method>
    <signal name="ProfileReleased">
      <arg type="u" name="cookie"/>
    </signal>
    <property type="s" name="ActiveProfile" access="readwrite"/>
    <property type="s" name="PerformanceInhibited" access="read"/>
    <property type="s" name="PerformanceDegraded" access="read"/>
    <property type="aa{sv}" name="Profiles" access="read"/>
    <property type="as" name="Actions" access="read"/>
    <property type="aa{sv}" name="ActionsInfo" access="read"/>
    <property type="aa{sv}" name="ActiveProfileHolds" access="read"/>
    <property type="s" name="Version" access="read"/>
    <property type="b" name="BatteryAware" access="readwrite"/>
  </interface>
"""


# --- D-Bus service implementing the power-profiles-daemon API
class ProfilesDaemon(dbus.service.Object):
    def __init__(self, bus):
        dbus.service.Object.__init__(self, bus, OBJECT_PATH)
        # Export on the legacy interface net.hadess.PowerProfiles and legacy path too
        self.SUPPORTS_MULTIPLE_OBJECT_PATHS = True
        dbus.service.Object.add_to_connection(self, bus, OBJECT_PATH_LEGACY)
        # Remember bus for _check_polkit_auth()
        self._bus = bus

        # Internal state
        self._active_profile = self._get_tlp_profile()  # Last profile applied by TLP
        self._selected_profile = (
            self._active_profile
        )  # Last profile received by Set(ActiveProfile)
        self._profiles = [
            {"Profile": f"{profile}", "CpuDriver": "tlp", "PlatformDriver": "tlp"}
            for profile in AVAILABLE_PROFILES
        ]
        self._performance_degraded = ""
        self._actions = []
        self._actions_info = []
        self._version = "@TLPVER@"
        self._battery_aware = False
        self._cookie_counter = 0
        self._holds = {}  # cookie -> {profile, reason, application_id, sender}

    # --- Interfaces org.freedesktop.UPower.PowerProfiles and net.hadess.PowerProfiles (legacy)

    @dbus.service.method(
        dbus_interface=INTERFACE_NAME,
        in_signature="sss",
        out_signature="u",
        sender_keyword="sender",
    )
    @dbus.service.method(
        dbus_interface=INTERFACE_NAME_LEGACY,
        in_signature="sss",
        out_signature="u",
        sender_keyword="sender",
    )
    def HoldProfile(self, profile, reason, application_id, sender=None):
        # Hold a new profile until:
        # - either it is released by ReleaseProfile()
        # - or another one is selected by the user via Set(ActiveProfile)
        if profile not in AVAILABLE_PROFILES:
            raise dbus.exceptions.DBusException(
                f"Invalid profile: {profile}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        # Check authorization first
        if not self._check_polkit_auth(sender, f"{BUS_NAME}.hold-profile"):
            raise dbus.exceptions.DBusException(
                "Not authorized to hold power profile",
                name="org.freedesktop.PolicyKit1.Error.NotAuthorized",
            )

        self._cookie_counter += 1
        cookie = self._cookie_counter

        self._holds[cookie] = {
            "profile": profile,
            "reason": reason,
            "application_id": application_id,
            "sender": sender,
        }

        logger.info(
            f"Profile hold created: {application_id} holds {profile} (cookie: {cookie}, reason: {reason})"
        )

        # Update active profile based on holds
        self._update_profile_from_holds()

        return dbus.UInt32(cookie)

    @dbus.service.method(
        dbus_interface=INTERFACE_NAME, in_signature="u", out_signature=""
    )
    @dbus.service.method(
        dbus_interface=INTERFACE_NAME_LEGACY, in_signature="u", out_signature=""
    )
    def ReleaseProfile(self, cookie):
        # Release a profile hold and revert to:
        # - either the previous held profile
        # - or the last profile selected by the user
        cookie = int(cookie)
        if cookie not in self._holds:
            raise dbus.exceptions.DBusException(
                f"Invalid cookie: {cookie}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        hold_rel = self._holds.pop(cookie)
        logger.info(
            f"Profile hold {hold_rel['profile']} released: {hold_rel['application_id']} (cookie: {cookie})"
        )

        # Update active profile based on remaining holds
        self._update_profile_from_holds()

    @dbus.service.method(
        dbus_interface=INTERFACE_NAME, in_signature="s", out_signature=""
    )
    @dbus.service.method(
        dbus_interface=INTERFACE_NAME_LEGACY, in_signature="s", out_signature=""
    )
    def SyncProfile(self, profile):
        # Callback for tlp after profile changes: update internal state only
        if profile not in AVAILABLE_PROFILES:
            raise dbus.exceptions.DBusException(
                f"Invalid profile: {profile}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        logger.debug(f"SyncProfile: {profile}")

        # Update active profile
        self._active_profile = profile

        # Notify the desktop about the new profile using the signal
        self.PropertiesChanged(INTERFACE_NAME, {"ActiveProfile": profile}, [])

    @dbus.service.signal(dbus_interface=INTERFACE_NAME, signature="u")
    # Exported on the interface org.freedesktop.UPower.PowerProfiles
    # Emitted when a profile hold is released due to manual profile change
    def ProfileReleased(self, cookie):
        logger.debug("Signal ProfileReleased")
        pass

    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE, signature="sa{sv}as")
    # Exported on the interface org.freedesktop.DBus.Properties
    # Emitted when the active profile changes
    def PropertiesChanged(
        self, interface_name, changed_properties, invalidated_properties
    ):
        logger.debug(
            f"Signal PropertiesChanged: interface={interface_name}, changed_properties={changed_properties}, invalidated_properties={invalidated_properties}"
        )
        pass

    # --- Interface org.freedesktop.DBus.Properties

    @dbus.service.method(
        dbus_interface=dbus.PROPERTIES_IFACE, in_signature="ss", out_signature="v"
    )
    def Get(self, interface_name, property_name):
        # Get a property value
        logger.debug("Method Get: interface={interface_name}, property={property_name}")

        if interface_name not in [INTERFACE_NAME, INTERFACE_NAME_LEGACY]:
            raise dbus.exceptions.DBusException(
                f"Unknown interface: {interface_name}",
                name="org.freedesktop.DBus.Error.UnknownInterface",
            )

        return self._get_property(property_name)

    @dbus.service.method(
        dbus_interface=dbus.PROPERTIES_IFACE, in_signature="s", out_signature="a{sv}"
    )
    def GetAll(self, interface_name):
        # Get all properties
        logger.debug(f"Method GetAll: interface={interface_name}")

        if interface_name not in [INTERFACE_NAME, INTERFACE_NAME_LEGACY]:
            raise dbus.exceptions.DBusException(
                f"Unknown interface: {interface_name}",
                name="org.freedesktop.DBus.Error.UnknownInterface",
            )

        return {
            f"{prop}": self._get_property(prop)
            for prop in [
                "ActiveProfile",
                "PerformanceInhibited",
                "PerformanceDegraded",
                "Profiles",
                "Actions",
                "ActionsInfo",
                "ActiveProfileHolds",
                "Version",
                "BatteryAware",
            ]
        }

    @dbus.service.method(
        dbus_interface=dbus.PROPERTIES_IFACE,
        in_signature="ssv",
        out_signature="",
        sender_keyword="sender",
    )
    def Set(self, interface_name, property_name, value, sender=None):
        # Set a property value
        logger.debug(
            f"Method Set: interface={interface_name}, property={property_name}, value={value}"
        )

        if interface_name not in [INTERFACE_NAME, INTERFACE_NAME_LEGACY]:
            raise dbus.exceptions.DBusException(
                f"Unknown interface: {interface_name}",
                name="org.freedesktop.DBus.Error.UnknownInterface",
            )

        self._set_property(property_name, value, sender)

    # --- Interface org.freedesktop.DBus.Introspectable

    @dbus.service.method(
        dbus_interface=dbus.INTROSPECTABLE_IFACE,
        in_signature="",
        out_signature="s",
        path_keyword="object_path",
        connection_keyword="connection",
    )
    def Introspect(self, object_path, connection):
        # Return introspection XML describing this service
        logger.debug(
            f"Method Introspect: object_path={object_path}, connection={connection}"
        )

        # Answer depending on the object path
        if object_path == OBJECT_PATH:
            return INTROSPECTION_XML.replace("@PD_INTERFACE@", INTERFACE_NAME)
        elif object_path == OBJECT_PATH_LEGACY:
            return INTROSPECTION_XML.replace("@PD_INTERFACE@", INTERFACE_NAME_LEGACY)
        else:
            raise dbus.exceptions.DBusException(
                f"(No such object path '{object_path}'",
                name="org.freedesktop.DBus.Error.UnknownObject",
            )

    # --- Helpers
    def _get_property(self, property_name):
        # Internal method to get property values
        if property_name == "ActiveProfile":
            return self._active_profile
        elif property_name == "PerformanceInhibited":
            return ""  # Deprecated
        elif property_name == "PerformanceDegraded":
            return self._performance_degraded
        elif property_name == "Profiles":
            return dbus.Array(self._profiles, signature="a{sv}")
        elif property_name == "Actions":
            return dbus.Array(self._actions, signature="s")
        elif property_name == "ActionsInfo":
            return (dbus.Array(self._actions_info, signature="aa{sv}"),)
        elif property_name == "ActiveProfileHolds":
            return self._get_active_profile_holds()
        elif property_name == "Version":
            return self._version
        elif property_name == "BatteryAware":
            return self._battery_aware
        else:
            raise dbus.exceptions.DBusException(
                f"Unknown property: {property_name}",
                name="org.freedesktop.DBus.Error.UnknownProperty",
            )

    def _set_property(self, property_name, value, sender):
        # Internal method to set property values
        if property_name == "ActiveProfile":
            # Check authorization first
            if not self._check_polkit_auth(sender, f"{BUS_NAME}.switch-profile"):
                raise dbus.exceptions.DBusException(
                    "Not authorized to switch power profile",
                    name="org.freedesktop.PolicyKit1.Error.NotAuthorized",
                )

            # User (manually) changes profile
            self._drop_all_holds()
            self._apply_profile_with_tlp(str(value))
            self._selected_profile = str(value)

        elif property_name == "BatteryAware":
            if value == "true":
                self._battery_aware = True
            else:
                self._battery_aware = False
        else:
            raise dbus.exceptions.DBusException(
                f"Property {property_name} is readonly",
                name="org.freedesktop.DBus.Error.PropertyReadOnly",
            )
            return

        # Notify the desktop about the changed property
        if property_name != "ActiveProfile":
            self.PropertiesChanged(INTERFACE_NAME, {f"{property_name}": value}, [])

    def _update_profile_from_holds(self):
        # Change active profile to the last hold in the list
        # If the hold list is empty, revert to the last user selected profile
        if len(self._holds) == 0:
            logger.info(
                f"Changing active profile from hold {self._active_profile} to last user selection {self._selected_profile}"
            )
            self._apply_profile_with_tlp(self._selected_profile)
        else:
            # Apply profile from the list's end
            last_cookie_key = list(self._holds)[-1]
            new_profile = self._holds[last_cookie_key]["profile"]
            new_appid = self._holds[last_cookie_key]["application_id"]
            old_profile = self._active_profile
            if new_profile != old_profile:
                logger.info(
                    f"Changing active profile from hold {old_profile} to {new_profile}: {new_appid} (cookie: {last_cookie_key})"
                )
                self._apply_profile_with_tlp(new_profile)
            else:
                logger.info(
                    f"Keeping active profile at hold {new_profile}: {new_appid} (cookie: {last_cookie_key})"
                )

    def _drop_all_holds(self):
        # Release all holds and notify holders
        cookies2release = list(self._holds.keys())
        for cookie in cookies2release:
            hold2release = self._holds.pop(cookie)
            logger.info(
                f"Auto-releasing hold {hold2release['profile']}: {hold2release['application_id']} (cookie: {cookie})"
            )

            # Emit ProfileReleased signal to the sender
            ### TODO: This is simplified; proper implementation would send to specific sender
            ### Q: how to emit on both interfaces?
            self.ProfileReleased(dbus.UInt32(cookie))

    def _get_active_profile_holds(self):
        # Get list of active profile holds
        active_holds = []
        for cookie, hold_info in self._holds.items():
            active_holds.append(
                {
                    "ApplicationId": hold_info["application_id"],
                    "Profile": hold_info["profile"],
                    "Reason": hold_info["reason"],
                }
            )
        return dbus.Array(active_holds, signature="a{sv}")

    # --- TLP helpers
    def _apply_profile_with_tlp(self, profile):
        # Call tlp to apply the new profile
        if profile not in AVAILABLE_PROFILES:
            raise dbus.exceptions.DBusException(
                f"Invalid profile: {profile}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        # Run tlp <profile> in detached mode to avoid deadlocks in the event loop
        # caused by tlp invoking SyncProfile
        logger.info(f"Run detached TLP to apply profile: {profile}")
        _ = subprocess.Popen(
            ["tlp", f"{profile}"],
            start_new_session=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.STDOUT,
        )

    def _get_tlp_profile(self):
        # Read TLP statefile and translate into the last profile applied
        with open(TLP_LAST_PROFILE, "r") as f:
            last_pwr = f.readline().strip()

        if last_pwr not in TLP_PROFILE_IDX:
            logger.warning(f"Unknown TLP profile: {last_pwr}")
            return "balanced"

        tlp_profile = AVAILABLE_PROFILES[int(last_pwr)]
        logger.debug(f"Current TLP profile: {tlp_profile}")

        return tlp_profile

    # --- PolicyKit helpers
    def _check_polkit_auth(self, sender, action_id):
        # Check if the D-Bus sender is authorized for the given PolicyKit action.
        # Args:
        # - sender: D-Bus sender string (e.g., ":1.234")
        # - action_id: PolicyKit action identifier (e.g., "org.freedesktop.UPower.PowerProfiles.switch-profile")
        # Returns: bool: True if authorized, False otherwise

        # Get PolicyKit authority interface
        polkit = self._bus.get_object(
            "org.freedesktop.PolicyKit1", "/org/freedesktop/PolicyKit1/Authority"
        )
        authority = dbus.Interface(
            polkit, dbus_interface="org.freedesktop.PolicyKit1.Authority"
        )

        # Get the process ID and start time for the sender
        dbus_obj = self._bus.get_object("org.freedesktop.DBus", "/org/freedesktop/DBus")
        dbus_iface = dbus.Interface(dbus_obj, dbus_interface="org.freedesktop.DBus")
        pid = dbus_iface.GetConnectionUnixProcessID(sender)

        # Build the subject for PolicyKit check
        # Subject type: unix-process with PID and start-time
        subject = (
            "unix-process",
            {
                "pid": dbus.UInt32(pid),
                "start-time": dbus.UInt64(0),  # 0 means "don't check start time"
            },
        )

        # Check authorization
        try:
            result = authority.CheckAuthorization(
                subject,
                action_id,
                {},  # details
                dbus.UInt32(
                    0x1
                ),  # flags: AllowUserInteraction (show auth dialog if needed)
                "",  # cancellation_id
            )
            # result is a tuple: (is_authorized, is_challenge, details)

            is_authorized = result[0]
            return bool(is_authorized)

        except dbus.exceptions.DBusException as e:
            logger.error(f"PolicyKit authorization check failed: {e}")
            return False


if __name__ == "__main__":
    # --- Parse arguments
    parser = argparse.ArgumentParser(description=f"{DAEMON_NAME}")
    _ = parser.add_argument(
        "--debug", "-D", action="store_true", help="log debugging messages"
    )
    args = parser.parse_args()

    # Check root privileges
    if os.geteuid() != 0:
        print(
            f"ERROR: root privileges are required to run the {DAEMON_NAME}.",
            file=sys.stderr,
        )
        sys.exit(1)

    # --- Set up logging
    logger = logging.getLogger(__name__)
    handler = logging.handlers.SysLogHandler(address="/dev/log", facility=LOG_DAEMON)
    logger.addHandler(handler)

    # Set syslog identifier "tlp-pd"
    formatter = logging.Formatter(f"{os.path.basename(__file__)}: %(message)s")
    handler.setFormatter(formatter)

    # Set syslog level
    if args.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    # --- Initialize D-Bus
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    # Connect to system bus
    bus = dbus.SystemBus()

    # Claim well-known names on the bus
    # Note: the name is released when the BusName object becomes unreferenced
    #   -> ignore "never used" lint warning
    bus_name = dbus.service.BusName(BUS_NAME, bus)
    bus_name_legacy = dbus.service.BusName(BUS_NAME_LEGACY, bus)

    # --- Create daemon instance
    daemon = ProfilesDaemon(bus)
    logger.info(f"{DAEMON_NAME} started.")
    logger.info(f"Interfaces: {BUS_NAME}, {BUS_NAME_LEGACY}")
    logger.info(f"Object path: {OBJECT_PATH}")
    logger.info(f"Arguments: {vars(args)}")
    logger.info(f"Start profile: {daemon.Get(INTERFACE_NAME, 'ActiveProfile')}")

    # --- Run main loop
    try:
        mainloop = GLib.MainLoop()
        mainloop.run()
    except KeyboardInterrupt:
        logger.info(f"{DAEMON_NAME} shutting down ...")
