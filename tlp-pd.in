#!/usr/bin/env python3
# TLP Profiles Daemon (TLP-PD)
# Implements the org.freedesktop.UPower.PowerProfile D-BUS interface with TLP as backend
#
# Copyright (c) 2025 Thomas Koch <linrunner at gmx.net> and others.
# SPDX-License-Identifier: GPL-2.0-or-later

from syslog import LOG_DAEMON
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib
import subprocess
import argparse
import logging
import logging.handlers
import os

# --- Constants
DAEMON_NAME = "TLP Profiles Daemon"
AVAILABLE_PROFILES = ["performance", "balanced", "power-saver"]

# --- D-Bus constants
BUS_NAME = "org.freedesktop.UPower.PowerProfiles"
INTERFACE_NAME = BUS_NAME
OBJECT_PATH = "/org/freedesktop/UPower/PowerProfiles"
BUS_NAME_LEGACY = "net.hadess.PowerProfiles"
INTERFACE_NAME_LEGACY = BUS_NAME_LEGACY
OBJECT_PATH_LEGACY = "/net/hadess/PowerProfiles"

# --- TLP constants
TLP_LAST_PROFILE = "@TLP_RUN@/last_pwr"
TLP_PROFILE_IDX = ["0", "1", "2"]


# --- D-Bus service implementing the power-profiles-daemon API
class ProfilesDaemon(dbus.service.Object):
    def __init__(self, bus):
        dbus.service.Object.__init__(self, bus, OBJECT_PATH)
        # Export on the legacy interface net.hadess.PowerProfiles and legacy path too
        self.SUPPORTS_MULTIPLE_OBJECT_PATHS = True
        dbus.service.Object.add_to_connection(self, bus, OBJECT_PATH_LEGACY)

        # Internal state
        self._active_profile = self._get_tlp_profile()
        self._profiles = []
        for profile in AVAILABLE_PROFILES:
            self._profiles.append({"Profile": f"{profile}", "Driver": "tlp"})
        self._performance_degraded = ""
        self._actions = []
        self._version = "@TLPVER@"
        self._cookie_counter = 0
        self._holds = {}  # cookie -> {profile, reason, application_id, sender}

    # --- Interfaces org.freedesktop.UPower.PowerProfiles and net.hadess.PowerProfiles (legacy)

    @dbus.service.method(
        dbus_interface=INTERFACE_NAME,
        in_signature="sss",
        out_signature="u",
        sender_keyword="sender",
    )
    @dbus.service.method(
        dbus_interface=INTERFACE_NAME_LEGACY,
        in_signature="sss",
        out_signature="u",
        sender_keyword="sender",
    )
    def HoldProfile(self, profile, reason, application_id, sender=None):
        # Hold a profile until released
        ### Q: do we need this resp. which client is actually using it?
        ### TODO: extend to AVAILABLE_PROFILES?
        if profile not in ["power-saver", "performance"]:
            raise dbus.exceptions.DBusException(
                f"Invalid profile: {profile}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        self._cookie_counter += 1
        cookie = self._cookie_counter

        self._holds[cookie] = {
            "profile": profile,
            "reason": reason,
            "application_id": application_id,
            "sender": sender,
        }

        logger.info(
            f"Profile hold created: {application_id} holds {profile} (cookie: {cookie})"
        )

        # Update active profile based on holds
        self._update_profile_from_holds()

        return dbus.UInt32(cookie)

    @dbus.service.method(
        dbus_interface=INTERFACE_NAME, in_signature="u", out_signature=""
    )
    @dbus.service.method(
        dbus_interface=INTERFACE_NAME_LEGACY, in_signature="u", out_signature=""
    )
    def ReleaseProfile(self, cookie):
        # Release a profile hold
        ### Q: do we need this resp. which client is actually using it?
        cookie = int(cookie)
        if cookie not in self._holds:
            raise dbus.exceptions.DBusException(
                f"Invalid cookie: {cookie}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        hold_info = self._holds.pop(cookie)
        logger.info(
            f"Profile hold released: {hold_info['application_id']} (cookie: {cookie})"
        )

        # Update active profile based on remaining holds
        self._update_profile_from_holds()

    @dbus.service.method(
        dbus_interface=INTERFACE_NAME, in_signature="s", out_signature=""
    )
    @dbus.service.method(
        dbus_interface=INTERFACE_NAME_LEGACY, in_signature="s", out_signature=""
    )
    def SyncProfile(self, profile):
        # Callback for tlp after profile changes: update internal state only
        if profile not in AVAILABLE_PROFILES:
            raise dbus.exceptions.DBusException(
                f"Invalid profile: {profile}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        logger.debug(f"SyncProfile: {profile}")

        # Update active profile
        self._active_profile = profile

        # Notify the desktop about the new profile using the signal
        self.PropertiesChanged(INTERFACE_NAME, {"ActiveProfile": profile}, [])

    @dbus.service.signal(dbus_interface=INTERFACE_NAME, signature="u")
    # Exported on the interface org.freedesktop.UPower.PowerProfiles
    # Emitted when a profile hold is released due to manual profile change
    def ProfileReleased(self, cookie):
        logger.debug("Signal ProfileReleased")
        pass

    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE, signature="sa{sv}as")
    # Exported on the interface org.freedesktop.DBus.Properties
    # Emitted when the active profile changes
    def PropertiesChanged(
        self, interface_name, changed_properties, invalidated_properties
    ):
        logger.debug(
            f"Signal PropertiesChanged: interface={interface_name}, changed_properties={changed_properties}, invalidated_properties={invalidated_properties}"
        )
        pass

    # --- Interface org.freedesktop.DBus.Properties

    @dbus.service.method(
        dbus_interface=dbus.PROPERTIES_IFACE, in_signature="ss", out_signature="v"
    )
    def Get(self, interface_name, property_name):
        # Get a property value
        logger.debug("Method Get: interface={interface_name}, property={property_name}")

        if interface_name not in [INTERFACE_NAME, INTERFACE_NAME_LEGACY]:
            raise dbus.exceptions.DBusException(
                f"Unknown interface: {interface_name}",
                name="org.freedesktop.DBus.Error.UnknownInterface",
            )

        return self._get_property(property_name)

    @dbus.service.method(
        dbus_interface=dbus.PROPERTIES_IFACE, in_signature="s", out_signature="a{sv}"
    )
    def GetAll(self, interface_name):
        # Get all properties
        logger.debug(f"Method GetAll: interface={interface_name}")

        if interface_name not in [INTERFACE_NAME, INTERFACE_NAME_LEGACY]:
            raise dbus.exceptions.DBusException(
                f"Unknown interface: {interface_name}",
                name="org.freedesktop.DBus.Error.UnknownInterface",
            )

        return {
            "ActiveProfile": self._active_profile,
            "PerformanceInhibited": "",  # Deprecated
            "PerformanceDegraded": self._performance_degraded,
            "Profiles": dbus.Array(self._profiles, signature="a{sv}"),
            "Actions": dbus.Array(self._actions, signature="s"),
            "ActiveProfileHolds": self._get_active_profile_holds(),
            "Version": self._version,
        }

    @dbus.service.method(
        dbus_interface=dbus.PROPERTIES_IFACE, in_signature="ssv", out_signature=""
    )
    def Set(self, interface_name, property_name, value):
        # Set a property value
        logger.debug(
            f"Method Set: interface={interface_name}, property={property_name}, value={value}"
        )

        if interface_name not in [INTERFACE_NAME, INTERFACE_NAME_LEGACY]:
            raise dbus.exceptions.DBusException(
                f"Unknown interface: {interface_name}",
                name="org.freedesktop.DBus.Error.UnknownInterface",
            )

        if property_name == "ActiveProfile":
            self._apply_profile_with_tlp(str(value))
        else:
            raise dbus.exceptions.DBusException(
                f"Property {property_name} is not writable",
                name="org.freedesktop.DBus.Error.PropertyReadOnly",
            )

    # --- Helpers
    def _get_property(self, property_name):
        # Internal method to get property values
        if property_name == "ActiveProfile":
            return self._active_profile
        elif property_name == "PerformanceInhibited":
            return ""  # Deprecated
        elif property_name == "PerformanceDegraded":
            return self._performance_degraded
        elif property_name == "Profiles":
            return dbus.Array(self._profiles, signature="a{sv}")
        elif property_name == "Actions":
            return dbus.Array(self._actions, signature="s")
        elif property_name == "ActiveProfileHolds":
            return self._get_active_profile_holds()
        elif property_name == "Version":
            return self._version
        else:
            raise dbus.exceptions.DBusException(
                f"Unknown property: {property_name}",
                name="org.freedesktop.DBus.Error.UnknownProperty",
            )

    def _update_profile_from_holds(self):
        # Update active profile based on current holds
        if not self._holds:
            # No holds, could revert to a default profile
            # For now, keep current profile
            return

        # TODO: AVAILABLE_PROFILES?
        # power-saver takes precedence over performance
        has_power_saver = any(
            h["profile"] == "power-saver" for h in self._holds.values()
        )
        has_performance = any(
            h["profile"] == "performance" for h in self._holds.values()
        )

        new_profile = None
        if has_power_saver:
            new_profile = "power-saver"
        elif has_performance:
            new_profile = "performance"

        if new_profile and new_profile != self._active_profile:
            old_profile = self._active_profile
            self._apply_profile_with_tlp(new_profile)

            logger.info(
                f"Active profile changed by hold: {old_profile} -> {new_profile}"
            )

    def _release_all_holds(self):
        # Release all holds when user manually changes profile
        cookies_to_release = list(self._holds.keys())
        for cookie in cookies_to_release:
            hold_info = self._holds.pop(cookie)
            logger.info(
                f"Auto-releasing hold: {hold_info['application_id']} (cookie: {cookie})"
            )

            # Emit ProfileReleased signal to the sender
            ### TODO: This is simplified; proper implementation would send to specific sender
            ### Q: how to emit on both interfaces?
            self.ProfileReleased(dbus.UInt32(cookie))

    def _get_active_profile_holds(self):
        # Get list of active profile holds
        holds = []
        for cookie, hold_info in self._holds.items():
            holds.append(
                {
                    "ApplicationId": hold_info["application_id"],
                    "Profile": hold_info["profile"],
                    "Reason": hold_info["reason"],
                }
            )
        return dbus.Array(holds, signature="a{sv}")

    # --- TLP helpers
    def _apply_profile_with_tlp(self, profile):
        # Call tlp to apply the new profile
        if profile not in AVAILABLE_PROFILES:
            raise dbus.exceptions.DBusException(
                f"Invalid profile: {profile}",
                name="org.freedesktop.DBus.Error.InvalidArgs",
            )

        # Release all holds and notify holders
        self._release_all_holds()

        # Run tlp <profile> in detached mode to avoid deadlocks in the event loop
        # caused by tlp invoking SyncProfile
        logger.info(f"Run detached TLP to apply profile: {profile}")
        _ = subprocess.Popen(
            ["tlp", f"{profile}"],
            start_new_session=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.STDOUT,
        )

    def _get_tlp_profile(self):
        # Read TLP statefile and translate into the last profile applied
        with open(TLP_LAST_PROFILE, "r") as f:
            last_pwr = f.readline().strip()

        if last_pwr not in TLP_PROFILE_IDX:
            logger.warning(f"Unknown TLP profile: {last_pwr}")
            return "balanced"

        tlp_profile = AVAILABLE_PROFILES[int(last_pwr)]
        logger.debug(f"Current TLP profile: {tlp_profile}")

        return tlp_profile


if __name__ == "__main__":
    # --- Parse arguments
    parser = argparse.ArgumentParser(description=f"{DAEMON_NAME}")
    _ = parser.add_argument(
        "--debug", "-D", action="store_true", help="log debugging messages"
    )
    args = parser.parse_args()

    # --- Set up logging
    logger = logging.getLogger(__name__)
    handler = logging.handlers.SysLogHandler(address="/dev/log", facility=LOG_DAEMON)
    logger.addHandler(handler)

    # Set syslog identifier "tlp-pd"
    formatter = logging.Formatter(f"{os.path.basename(__file__)}: %(message)s")
    handler.setFormatter(formatter)

    # Set syslog level
    if args.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    # --- Initialize D-Bus
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    # Connect to system bus
    bus = dbus.SystemBus()

    # Claim well-known names on the bus
    # Note: the name is released when the BusName object becomes unreferenced
    #   -> ignore "never used" lint warning
    bus_name = dbus.service.BusName(BUS_NAME, bus)
    bus_name_legacy = dbus.service.BusName(BUS_NAME_LEGACY, bus)

    # --- Create daemon instance
    daemon = ProfilesDaemon(bus)
    logger.info(f"{DAEMON_NAME} started.")
    logger.info(f"Interfaces: {BUS_NAME}, {BUS_NAME_LEGACY}")
    logger.info(f"Object path: {OBJECT_PATH}")
    logger.info(f"Arguments: {vars(args)}")
    logger.info(f"Start profile: {daemon.Get(INTERFACE_NAME, 'ActiveProfile')}")

    # --- Run main loop
    try:
        mainloop = GLib.MainLoop()
        mainloop.run()
    except KeyboardInterrupt:
        logger.info(f"{DAEMON_NAME} shutting down ...")
